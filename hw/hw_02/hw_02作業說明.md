# 在這個目錄下建立一個檔案名稱為： "ＨＷ02_學號.ipynb"
# 寫完之後執行下列指令(請將下列的...改成有意義的內容): 
sh /workspaces/geophysics-class-2025/./git_all.sh "update ...."
----------------------------------------------------------------------------------
地球物理程式作業：重力正演模擬（簡化版與詳盡提示）
一、 作業目標 (Objective)
這個作業的目標很簡單：讓你親手體驗地球物理學家如何「猜測」地下的樣子。你只需要修改幾個數字，然後觀察圖形的變化，最終讓一條曲線和一些數據點對齊即可。我們會引導你完成每一步。

二、 背景說明 (Background)
想像一下，我們在地面上量到了一些奇怪的重力讀數（就是那些紅色數據點），這暗示地底下可能埋了什麼東西。我們的任務就是利用物理公式和電腦，建立一個虛擬的地下模型（比如一個圓柱體），然後調整這個模型的大小、深度、密度，看看它產生的理論重力曲線（藍色線）能不能剛好穿過我們量到的那些數據點。這個過程就叫做「正演模擬」。

三、 你的任務：成為「模型調整師」
你的工作不是從零開始寫程式，而是使用我們提供好的程式碼，像玩模擬遊戲一樣，調整裡面的三個參數，直到模擬結果符合觀測數據。

要調整的 3 個參數：

model_delta_rho: 地下圓柱體和周圍岩石的密度差 (數字越大，代表物體越重)。

model_R: 圓柱體的半徑 (數字越大，代表物體越胖)。

model_z: 圓柱體中心的深度 (數字越大，代表埋得越深)。

四、 攻略步驟 (Step-by-Step Guide)
第一步：準備好你的「模擬器」(程式碼)
直接複製下面的完整 Python 程式碼，並在一個可以執行 Python 的環境中貼上（例如 Google Colab, Jupyter Notebook, 或任何安裝了 Python 的編輯器）。

Python

import numpy as np
import matplotlib.pyplot as plt

# --- 物理常數 (這些不用動) ---
G = 6.674e-11      # 萬有引力常數
MGAL_CONVERSION = 1e5 # 單位轉換因子，將 m/s^2 轉為 mGal

# --- 觀測數據 (這些是我們要擬合的目標，不用動) ---
x_observed = np.array([-500, -400, -300, -200, -100, 0, 100, 200, 300, 400, 500])
g_observed = np.array([0.35, 0.52, 0.90, 1.69, 3.42, 4.65, 3.38, 1.72, 0.88, 0.55, 0.33])

# --- 計算重力的函式 (這個函式已經寫好了，不用動) ---
def calculate_gravity_anomaly(x_array, delta_rho, R, z):
    numerator = 2 * np.pi * G * delta_rho * (R**2) * z
    denominator = x_array**2 + z**2
    g_z_si_units = numerator / denominator
    return g_z_si_units * MGAL_CONVERSION

# ==============================================================================
# ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼ 你唯一需要修改的地方就在這裡 ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
# ==============================================================================

# 這是你的模型參數，試著調整下面這三個數字！
model_delta_rho = 800.0  # 密度差 (kg/m^3)，試試 500 ~ 1500 之間的值
model_R = 20.0           # 半徑 (m)，試試 30 ~ 80 之間的值
model_z = 150.0          # 深度 (m)，試試 80 ~ 200 之間的值

# ==============================================================================
# ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
# ==============================================================================

# --- 計算與繪圖 (下面的程式碼會自動執行，不用動) ---
x_model = np.linspace(-500, 500, 200)
g_predicted = calculate_gravity_anomaly(x_model, model_delta_rho, model_R, model_z)

plt.figure(figsize=(10, 6))
plt.scatter(x_observed, g_observed, color='red', s=50, zorder=5, label='觀測數據 (目標)')
plt.plot(x_model, g_predicted, color='blue', linewidth=2, label='你的模型預測曲線')
plt.title('重力正演模擬', fontsize=16)
plt.xlabel('位置 x (m)')
plt.ylabel('重力異常 (mGal)')
plt.grid(True, linestyle='--', alpha=0.6)
plt.legend()
plt.show()

第二步：執行程式，觀察第一次結果
直接執行上面的程式碼，你會看到一張圖。圖上有紅色的點（我們的目標）和一條藍色的線（你目前的猜測）。很可能第一次的藍線和紅點對得不太好，這很正常！

第三步：開始調整！(模型調整攻略)
現在，回到程式碼中你唯一需要修改的三行，根據下面的提示來調整數字，然後重新執行程式，看看藍線有什麼變化。

調整順序建議：先調寬度，再調高度！

調整曲線的「胖瘦」(寬度)：

由 model_z (深度) 控制。

提示：

如果你的藍線比紅點分佈得更「胖」更「寬」，說明你猜的物體埋得太深了，試著減小 model_z 的值（例如從 150 改成 120）。

如果你的藍線比紅點分佈得更「瘦」更「窄」，說明埋得太淺了，試著增大 model_z 的值。

重複調整 model_z，直到藍線的寬度看起來和紅點的寬度差不多。

調整曲線的「高低」(峰值)：

由 model_delta_rho (密度差) 和 model_R (半徑) 共同控制。

提示：

當寬度差不多對了之後，如果藍線的最高點低於最中間的紅點，說明你的物體不夠「重」或不夠「大」。試著增大 model_delta_rho 或 model_R 的值。建議先固定一個（例如R），只調整另一個（delta_rho）。

如果藍線的最高點高於最中間的紅點，就減小 model_delta_rho 或 model_R 的值。

重複調整，直到藍線的峰值也和紅點對上。

不斷重複「修改數字 -> 執行程式 -> 觀察圖形」這個循環，直到你覺得藍線完美地穿過了所有紅點！

五、 繳交內容 (Deliverables)
當你對你的擬合結果滿意後，請繳交一份簡單的報告，包含以下內容：

你的最終模型參數：

你找到的最佳 model_delta_rho 是多少？

你找到的最佳 model_R 是多少？

你找到的最佳 model_z 是多少？

最終結果圖：

將你覺得最完美的「藍線穿過紅點」的那張圖截圖下來，貼到報告中。

簡單問答（憑你的觀察回答即可）：

問題一：當你把 model_z (深度) 的數字變大時，圖上的藍色曲線是變寬了還是變窄了？

問題二：如果你想讓藍色曲線的峰值（最高點）變得更高，你應該增大還是減小 model_delta_rho (密度差) 的值？

這個簡化版的作業移除了所有複雜的理論推導和開放性問題，將重點放在直觀的操作和觀察上，讓學生能在沒有壓力的情況下，掌握正演模擬的核心思想。